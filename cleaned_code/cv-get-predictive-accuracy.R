# Yates Coley
# rycoley@gmail.com
# 2019 January 08
# This script summarizes accuracy of true state predictions for patients with true state known (from complete CV model re-estimation). AUC, MSE, and MAE are written to csv files.
# This script also generates a pdf with ROC curves and calibration plots



#### WORKFLOW
### 1. Clear workspace
### 2. Define directories, file names
### 3. Load libraries, helper functions
### 4. Load needed data and predictions
### 5. Calculate AUC, MSE, MAE
### 6. Plot ROC curves and calibration


### 1. Clear workspace
rm(list=ls())
mri_role = 0
### 2. Define directories
#User will need to edit
#This uses CV data and directory locations
base.location <- "/Users/zitongwang/Downloads/prostate-active-surveillance-vDaan/"
location.of.data <- paste0(base.location, "data", sep="") 
location.of.r.scripts <- paste0(base.location, "R-script", sep="")
location.of.generated.files <- paste0(base.location, "generated-files-sh", sep="")

# #options to put the plots generated by this script in a different directory
# location.of.assessment.summaries <- location.of.generated.files #paste0(base.location, "generated-files")# "/Users/ryc/Documents/inhealth/prediction-model/automated/for-TIC-assessment-summaries/generated-files"
# 

### 3. Load libraries, helper functions
library("pROC")
library("ROCR")
library("splines")

#define inverse logit function
expit<-function(x){return(exp(x)/(1+exp(x)))}



### 4. Load needed data and predictions
#load(paste(location.of.generated.files,"IOP-data-shaping-work-space.RData", sep="/"))
load("~/Downloads/prostate-active-surveillance-vDaan/generated-files-cv/IOP-data-shaping-work-space.RData")
#number of patients
(n <- dim(pt.data)[1])

#get observed PGGs
eta.data<-pt.data$true.pgg
obs.eta<-eta.data[!is.na(eta.data)]
#put in matrix for PGG>1, PGG>2, PGG>3
obs.eta.mat<-cbind(as.numeric(obs.eta>1), as.numeric(obs.eta>2), as.numeric(obs.eta>3))

K<-4 #number of classes
B<-750  #number of posterior samples

(N<-length(obs.eta))

#list of known true states
eta.true <- pt.data$true.pgg[!is.na(pt.data$true.pgg)]
#number with known true state
n_eta_known <- length(eta.true)

# # get CV groups for 10 folds
# set.seed(44)
# my.sample <- sample(1:n_eta_known)
# folds <- cut(seq(1, n_eta_known), breaks=10, labels=F)
# pt.data$cvgroup<-rep(0,n)
# for(group in 1:10){
#   pt.data$cvgroup[my.sample[folds==group]] <- group}

#get eta predictions
ptdata_cvgroup <- pt.data$cvgroup[1:N] ## 04/15/22 Zitong
fitted.eta<-matrix(nrow=B, ncol=N)
for(group in 1:10){
  obs_eta_cv <- read.csv(paste0(base.location, "generated-files-cv/eta-subj-",group,".csv"))
	fit_eta_cv <- read.csv(paste0(location.of.generated.files, "/jags-prediction-eta.track-",group,".csv"))
	fit_eta_cv <- fit_eta_cv[,-1]
	group_inx <- which(pt.data$subj %in% obs_eta_cv$subj)
	for(icol in 1:length(group_inx)){
	  fitted.eta[,group_inx[icol]] <- fit_eta_cv[,icol]
	}
} ## 04/15/22 Zitong
sum(is.na(fitted.eta)) == 0 # needs to be TRUE
#put into matrix for PGG>1, >2, >3
fitted.inf.obs <- matrix(nrow=N, ncol=(K-1))
for(i in 1:N){for(k in 1:(K-1)){
		fitted.inf.obs[i,k] <- sum(fitted.eta[,i]>k)/B } }



## 5. Calculate AUC -------
auc.inf.obs<-vector(length=3)
ci.inf.obs<-matrix(nrow=3, ncol=2)
for(j in 1:3){
	auc.inf.obs[j] <-performance( prediction( fitted.inf.obs[,j], obs.eta.mat[,j]), "auc")@y.values[[1]] 
	ci.fit <- ci.auc(response=obs.eta.mat[,j], predictor=fitted.inf.obs[,j], method="bootstrap")
	ci.inf.obs[j,] <- c(ci.fit[1], ci.fit[3])}
auc.inf.obs
#save
#write.csv(as.matrix(cbind(auc.inf.obs, ci.inf.obs)), paste0(location.of.assessment.summaries,"/cv-auc-eta-known.csv"))


# ## 6. obs_eta versus fitted_eta -----------
# obs_fitted_table <- list()
# for(irow in 1:nrow(fitted.eta)){
#   fitted.eta.i <- fitted.eta[irow,]
#   tmp_tbl <- table(obs.eta, fitted.eta.i)
#   obs_fitted_table[[irow]] <- matrix(tmp_tbl, ncol = ncol(tmp_tbl), dimnames = dimnames(tmp_tbl))
# }
# 
# ave_obs_fitted <- Reduce("+", obs_fitted_table)/length(obs_fitted_table)
# round(ave_obs_fitted)
# ## fitted_eta versus biopsy data
# data.check <- function(condition, message){
#   if(condition==FALSE){print(paste(message, "Program terminated.", sep=" "))}
#   stopifnot(condition)}
# #load("generated-files-cv/IOP-data-shaping-work-space.RData")
# #source("R-script/new/data-prep-for-jags-seq-wo-mri.R")
# pt.data.short <- pt.data %>% 
#   dplyr::select(clinical_PTnum, true.pgg, bx.pgg) %>% 
#   filter(!is.na(true.pgg))
# 
# bgg_fittedeta_table <- list()
# for(irow in 1:nrow(fitted.eta)){
#   fitted.eta.i <- fitted.eta[irow,]
#   pt.data.short$fitted.pgg <- fitted.eta.i
#   tmp.pt.data <- pt.data
#   tmp.pt.data <- pt.data %>% left_join(pt.data.short,by = c("clinical_PTnum", "true.pgg", "bx.pgg"))
#   pgg.data$fitted.pgg <- tmp.pt.data$fitted.pgg[pgg.data$subj]
#   pgg.data2$fitted.pgg <- tmp.pt.data$fitted.pgg[pgg.data2$subj]
#   fitted_pgg <- c(pgg.data$fitted.pgg, pgg.data2$fitted.pgg)
#   
#   tmp_tbl <- table(fitted_pgg, pgg_data)
#   bgg_fittedeta_table[[irow]] <- matrix(tmp_tbl, ncol = ncol(tmp_tbl), dimnames = dimnames(tmp_tbl))
# }
# 
# 
# 
# ave_bgg_fittedeta <- Reduce("+", bgg_fittedeta_table)/length(bgg_fittedeta_table)
# round(ave_bgg_fittedeta)
# 

##fitted_eta versus fitted biopsy assuming pgg_slope[11] = 0 ----------- 
library(readr)
loc_coef <- "generated-files/generated-files-new/seq-mri-moderator-form3/"
pgg_int1 <- read_csv(paste0(loc_coef, "jags-prediction-pgg_int1-2022.csv"))
pgg_int2 <- read_csv(paste0(loc_coef, "jags-prediction-pgg_int2-2022.csv"))
pgg_int3 <- read_csv(paste0(loc_coef, "jags-prediction-pgg_int3-2022.csv"))
pgg_slope1 <-  read_csv(paste0(loc_coef, "jags-prediction-pgg_slope1-2022.csv"))
pgg_slope2 <-  read_csv(paste0(loc_coef, "jags-prediction-pgg_slope2-2022.csv"))
pgg_slope3 <-  read_csv(paste0(loc_coef, "jags-prediction-pgg_slope3-2022.csv"))

pg_int1 <- as.matrix(pgg_int1[,-1])
pg_int2 <- as.matrix(pgg_int2[,-1])
pg_int3 <- as.matrix(pgg_int3[,-1])
pg_slope1 <- as.matrix(pgg_slope1[,-1])
pg_slope2 <- as.matrix(pgg_slope2[,-1])
pg_slope3 <- as.matrix(pgg_slope3[,-1])

# pgg_int1 <- apply(pg_int1,2,mean);pgg_int2 <- apply(pg_int2,2,mean);pgg_int3 <- apply(pg_int3,2,mean)
# pgg_slope1 <- apply(pg_slope1,2,mean);pgg_slope2 <- apply(pg_slope2,2,mean);pgg_slope3 <- apply(pg_slope3,2,mean)
# 
# pgg_slope1 <- as.matrix(pgg_slope1)
# pgg_slope2 <- as.matrix(pgg_slope2)
# pgg_slope3 <- as.matrix(pgg_slope3)

data.check <- function(condition, message){
  if(condition==FALSE){print(paste(message, "Program terminated.", sep=" "))}
  stopifnot(condition)}
source(paste0(location.of.r.scripts, "/new/data-prep-for-jags-seq-mri-moderator.R"))
## update covariate matrix for biopsy model with eta predictions
K = 4
eta.data<-pt.data$true.pgg
etahat<-read.csv(paste0(loc_coef, "/jags-prediction-cancer_state-2022.csv"))
etahat<-as.matrix(etahat[,2:dim(etahat)[2]])
(n <- dim(pt.data)[1])
(B<-dim(etahat)[1]) #length of saved posterior chain
#mean eta predictions for patients with unknown cancer state
pred_eta <- matrix(nrow=(n-npat_cancer_known), ncol=K)
for(i in 1:(n-npat_cancer_known)){for(k in 1:K){
  pred_eta[i,k] <- sum(etahat[,i]==k)/B }}

V.PGG.eta<-matrix(nrow=npat_pgg, ncol=(K-1))
for(j in 1:npat_pgg){
  if(pgg_patient_index_map[j] <= npat_cancer_known){
    for(k in 1:(K-1)){
      V.PGG.eta[j,k] <- as.numeric(eta.data[pgg_patient_index_map[j]]>k)}}
  else{
    for(k in 1:(K-1)){
      V.PGG.eta[j,k] <- 1-sum(pred_eta[(pgg_patient_index_map[j]-npat_cancer_known),1:k]) } } }

modmat_pg <- cbind(modmat_pgg, V.PGG.eta)
expon_pg1 <- expit(as.vector(pg_int1) + t(modmat_pg %*% t(pg_slope1[,-11]))) ## assume pgg_slope[11] = 0 
expon_pg2 <- expit(as.vector(pg_int2) + t(modmat_pg %*% t(pg_slope2[,-11])))
expon_pg3 <- expit(as.vector(pg_int3) + t(modmat_pg %*% t(pg_slope3[,-11])))

p_pg1_given_coef <- expon_pg1
p_pg2_given_coef <- (1-expon_pg1) * expon_pg2
p_pg3_given_coef <- (1-expon_pg1) * (1-expon_pg2) *expon_pg3
p_pg4_given_coef <- 1-(p_pg1_given_coef + p_pg2_given_coef + p_pg3_given_coef)

# ##fitted_eta versus fitted biopsy assuming pgg_slope[11] = posterior mean ----------- 
## assuming everyone has pirads of 3
pgg_pirads_data_m2_old <- pgg_pirads_data_m2
pgg_pirads_data_old <- pgg_pirads_data
pgg_pirads_data_m2 <- rep(3-2, length(pgg_pirads_data_m2_old))
pgg_pirads_data <- rep(3, length(pgg_pirads_data_m2_old))


#form4
V.pgg1.pirads <-  (V.PGG.eta[,1]-(1-V.PGG.eta[,1])) * ifelse(pgg_pirads_data[pgg_patient_index_map] >= 3, 1, 0) * pgg_pirads_data_m2[pgg_patient_index_map]
#form3
#V.pgg1.pirads <-  V.PGG.eta[,1] * ifelse(pgg_pirads_data[pgg_patient_index_map] >= 3, 1, 0) * pgg_pirads_data_m2[pgg_patient_index_map] 
#form2
#V.pgg1.pirads <-  V.PGG.eta[,1] * ifelse(pgg_pirads_data[pgg_patient_index_map] >= 3, 1, 0)
V.pgg1.pirads <- as.matrix(V.pgg1.pirads, ncol = 1)
modmat_pgg1 <- cbind(modmat_pgg, V.PGG.eta, V.pgg1.pirads)

V.pgg2.pirads <- (V.PGG.eta[,2]-(1-V.PGG.eta[,2])) * ifelse(pgg_pirads_data[pgg_patient_index_map] >= 3, 1, 0) * pgg_pirads_data_m2[pgg_patient_index_map] 
#V.pgg2.pirads <- V.PGG.eta[,2] * ifelse(pgg_pirads_data[pgg_patient_index_map] >= 3, 1, 0) * pgg_pirads_data_m2[pgg_patient_index_map] 
#V.pgg2.pirads <- V.PGG.eta[,2] * ifelse(pgg_pirads_data[pgg_patient_index_map] >= 3, 1, 0)
V.pgg2.pirads <- as.matrix(V.pgg2.pirads, ncol = 1)
modmat_pgg2 <- cbind(modmat_pgg, V.PGG.eta, V.pgg2.pirads)

V.pgg3.pirads <- (V.PGG.eta[,3]-(1-V.PGG.eta[,3])) * ifelse(pgg_pirads_data[pgg_patient_index_map] >= 3, 1, 0) * pgg_pirads_data_m2[pgg_patient_index_map] 
#V.pgg3.pirads <- V.PGG.eta[,3] * ifelse(pgg_pirads_data[pgg_patient_index_map] >= 3, 1, 0) * pgg_pirads_data_m2[pgg_patient_index_map] 
#V.pgg3.pirads <- V.PGG.eta[,3] * ifelse(pgg_pirads_data[pgg_patient_index_map] >= 3, 1, 0)
V.pgg3.pirads <- as.matrix(V.pgg3.pirads, ncol = 1)
modmat_pgg3 <- cbind(modmat_pgg, V.PGG.eta, V.pgg3.pirads)


## 4x4 table for patients w/ pirads >=3 letting beta4 = 0, -1, -2 comparison-----------------
pgg_pirads_data_mapped <- pgg_pirads_data[pgg_patient_index_map]
eta_data_mapped <- eta.data[pgg_patient_index_map]
inx_etaof1 <- which(eta_data_mapped==1)
inx_etaof1_pirads3plus <- which(pgg_pirads_data_mapped[inx_etaof1] >= 3)
inx_etaof2 <- which(eta_data_mapped==2)
inx_etaof2_pirads3plus <- which(pgg_pirads_data_mapped[inx_etaof2] >= 3)
inx_etaof3 <- which(eta_data_mapped==3)
inx_etaof3_pirads3plus <- which(pgg_pirads_data_mapped[inx_etaof3] >= 3)
inx_etaof4 <- which(eta_data_mapped==4)
inx_etaof4_pirads3plus <- which(pgg_pirads_data_mapped[inx_etaof4] >= 3)

get_eta_fittedbgg_table <- function(p_pg1_b4ofx, p_pg2_b4ofx, p_pg3_b4ofx,p_pg4_b4ofx){
  eta_fittedbgg_table <- list()
  for(irow in 1:nrow(p_pg1_b4ofx)){
    p_pg1_i <- p_pg1_b4ofx[irow,]
    p_pg2_i <- p_pg2_b4ofx[irow,]
    p_pg3_i <- p_pg3_b4ofx[irow,]
    p_pg4_i <- p_pg4_b4ofx[irow,]
    
    p_pg1_i_eta1 <- p_pg1_i[inx_etaof1]; p_pg2_i_eta1 <- p_pg2_i[inx_etaof1]
    p_pg3_i_eta1 <- p_pg3_i[inx_etaof1]; p_pg4_i_eta1 <- p_pg4_i[inx_etaof1]
    
    p_pg1_i_eta2 <- p_pg1_i[inx_etaof2]; p_pg2_i_eta2 <- p_pg2_i[inx_etaof2]
    p_pg3_i_eta2 <- p_pg3_i[inx_etaof2]; p_pg4_i_eta2 <- p_pg4_i[inx_etaof2]
    
    p_pg1_i_eta3 <- p_pg1_i[inx_etaof3]; p_pg2_i_eta3 <- p_pg2_i[inx_etaof3]
    p_pg3_i_eta3 <- p_pg3_i[inx_etaof3]; p_pg4_i_eta3 <- p_pg4_i[inx_etaof3]
    
    p_pg1_i_eta4 <- p_pg1_i[inx_etaof4]; p_pg2_i_eta4 <- p_pg2_i[inx_etaof4]
    p_pg3_i_eta4 <- p_pg3_i[inx_etaof4]; p_pg4_i_eta4 <- p_pg4_i[inx_etaof4]
    
    bgg1_given_eta1 = sum(p_pg1_i_eta1[inx_etaof1_pirads3plus])
    bgg1_given_eta2 = sum(p_pg1_i_eta2[inx_etaof2_pirads3plus])
    bgg1_given_eta3 = sum(p_pg1_i_eta3[inx_etaof3_pirads3plus])
    bgg1_given_eta4 = sum(p_pg1_i_eta4[inx_etaof4_pirads3plus])
    
    bgg2_given_eta1 = sum(p_pg2_i_eta1[inx_etaof1_pirads3plus])
    bgg2_given_eta2 = sum(p_pg2_i_eta2[inx_etaof2_pirads3plus])
    bgg2_given_eta3 = sum(p_pg2_i_eta3[inx_etaof3_pirads3plus])
    bgg2_given_eta4 = sum(p_pg2_i_eta4[inx_etaof4_pirads3plus])
    
    bgg3_given_eta1 = sum(p_pg3_i_eta1[inx_etaof1_pirads3plus])
    bgg3_given_eta2 = sum(p_pg3_i_eta2[inx_etaof2_pirads3plus])
    bgg3_given_eta3 = sum(p_pg3_i_eta3[inx_etaof3_pirads3plus])
    bgg3_given_eta4 = sum(p_pg3_i_eta4[inx_etaof4_pirads3plus])
    
    bgg4_given_eta1 = sum(p_pg4_i_eta1[inx_etaof1_pirads3plus])
    bgg4_given_eta2 = sum(p_pg4_i_eta2[inx_etaof2_pirads3plus])
    bgg4_given_eta3 = sum(p_pg4_i_eta3[inx_etaof3_pirads3plus])
    bgg4_given_eta4 = sum(p_pg4_i_eta4[inx_etaof4_pirads3plus])
    
    row_etaof1 <- c(bgg1_given_eta1, bgg2_given_eta1, bgg3_given_eta1, bgg4_given_eta1)
    row_etaof2 <- c(bgg1_given_eta2, bgg2_given_eta2, bgg3_given_eta2, bgg4_given_eta2)
    row_etaof3 <- c(bgg1_given_eta3, bgg2_given_eta3, bgg3_given_eta3, bgg4_given_eta3)
    row_etaof4 <- c(bgg1_given_eta4, bgg2_given_eta4, bgg3_given_eta4, bgg4_given_eta4)
    
    eta_fittedbgg_table[[irow]] <- rbind(row_etaof1,row_etaof2,row_etaof3,row_etaof4)
    
  }
  return(eta_fittedbgg_table)
}
#beta4 = 0
pg_slope1_b4of0 <- pg_slope1; pg_slope1_b4of0[,11] <- 0
pg_slope2_b4of0 <- pg_slope2; pg_slope2_b4of0[,11] <- 0
pg_slope3_b4of0 <- pg_slope3; pg_slope3_b4of0[,11] <- 0

expon_pg1_b4of0 <- expit(as.vector(pg_int1) + t(modmat_pgg1 %*% t(pg_slope1_b4of0))) ## assume pgg_slope[11] = 0 
expon_pg2_b4of0 <- expit(as.vector(pg_int2) + t(modmat_pgg2 %*% t(pg_slope2_b4of0)))
expon_pg3_b4of0 <- expit(as.vector(pg_int3) + t(modmat_pgg3 %*% t(pg_slope3_b4of0)))

p_pg1_b4of0 <- expon_pg1_b4of0
p_pg2_b4of0 <- (1-expon_pg1_b4of0) * expon_pg2_b4of0
p_pg3_b4of0 <- (1-expon_pg1_b4of0) * (1-expon_pg2_b4of0) *expon_pg3_b4of0
p_pg4_b4of0 <- 1-(p_pg1_b4of0 + p_pg2_b4of0 + p_pg3_b4of0)

eta_fittedbgg_b4of0 <- get_eta_fittedbgg_table(p_pg1_b4of0, p_pg2_b4of0, p_pg3_b4of0, p_pg4_b4of0)
#ave_eta_fittedbgg_b4of0 <- get_eta_fittedbgg_table(p_pg1_given_coef, p_pg2_given_coef, p_pg3_given_coef, p_pg4_given_coef) #would give same results
ave_eta_fittedbgg_b4of0 <- Reduce("+", eta_fittedbgg_b4of0)/length(eta_fittedbgg_b4of0)
round(ave_eta_fittedbgg_b4of0,2)

#beta4 = -1
pg_slope1_b4ofn1 <- pg_slope1; pg_slope1_b4ofn1[,11] <- -1
pg_slope2_b4ofn1 <- pg_slope2; pg_slope2_b4ofn1[,11] <- -1
pg_slope3_b4ofn1 <- pg_slope3; pg_slope3_b4ofn1[,11] <- -1

expon_pg1_b4ofn1 <- expit(as.vector(pg_int1) + t(modmat_pgg1 %*% t(pg_slope1_b4ofn1))) ## assume pgg_slope[11] = 0 
expon_pg2_b4ofn1 <- expit(as.vector(pg_int2) + t(modmat_pgg2 %*% t(pg_slope2_b4ofn1)))
expon_pg3_b4ofn1 <- expit(as.vector(pg_int3) + t(modmat_pgg3 %*% t(pg_slope3_b4ofn1)))

p_pg1_b4ofn1 <- expon_pg1_b4ofn1
p_pg2_b4ofn1 <- (1-expon_pg1_b4ofn1) * expon_pg2_b4ofn1
p_pg3_b4ofn1 <- (1-expon_pg1_b4ofn1) * (1-expon_pg2_b4ofn1) *expon_pg3_b4ofn1
p_pg4_b4ofn1 <- 1-(p_pg1_b4ofn1 + p_pg2_b4ofn1 + p_pg3_b4ofn1)

eta_fittedbgg_b4ofn1 <- get_eta_fittedbgg_table(p_pg1_b4ofn1, p_pg2_b4ofn1, p_pg3_b4ofn1, p_pg4_b4ofn1)
ave_eta_fittedbgg_b4ofn1 <- Reduce("+", eta_fittedbgg_b4ofn1)/length(eta_fittedbgg_b4ofn1)
round(ave_eta_fittedbgg_b4ofn1,2)

#beta4 = -3
pg_slope1_b4ofn3 <- pg_slope1; pg_slope1_b4ofn3[,11] <- -3
pg_slope2_b4ofn3 <- pg_slope2; pg_slope2_b4ofn3[,11] <- -3
pg_slope3_b4ofn3 <- pg_slope3; pg_slope3_b4ofn3[,11] <- -3

expon_pg1_b4ofn3 <- expit(as.vector(pg_int1) + t(modmat_pgg1 %*% t(pg_slope1_b4ofn3))) ## assume pgg_slope[11] = -2 
expon_pg2_b4ofn3 <- expit(as.vector(pg_int2) + t(modmat_pgg2 %*% t(pg_slope2_b4ofn3)))
expon_pg3_b4ofn3 <- expit(as.vector(pg_int3) + t(modmat_pgg3 %*% t(pg_slope3_b4ofn3)))

p_pg1_b4ofn3 <- expon_pg1_b4ofn3
p_pg2_b4ofn3 <- (1-expon_pg1_b4ofn3) * expon_pg2_b4ofn3
p_pg3_b4ofn3 <- (1-expon_pg1_b4ofn3) * (1-expon_pg2_b4ofn3) *expon_pg3_b4ofn3
p_pg4_b4ofn3 <- 1-(p_pg1_b4ofn3 + p_pg2_b4ofn3 + p_pg3_b4ofn3)

eta_fittedbgg_b4ofn3 <- get_eta_fittedbgg_table(p_pg1_b4ofn3, p_pg2_b4ofn3, p_pg3_b4ofn3, p_pg4_b4ofn3)
ave_eta_fittedbgg_b4ofn3 <- Reduce("+", eta_fittedbgg_b4ofn3)/length(eta_fittedbgg_b4ofn3)
round(ave_eta_fittedbgg_b4ofn3,2)

#beta4 = -10
pg_slope1_b4ofn10 <- pg_slope1; pg_slope1_b4ofn10[,11] <- -20
pg_slope2_b4ofn10 <- pg_slope2; pg_slope2_b4ofn10[,11] <- -20
pg_slope3_b4ofn10 <- pg_slope3; pg_slope3_b4ofn10[,11] <- -20

expon_pg1_b4ofn10 <- expit(as.vector(pg_int1) + t(modmat_pgg1 %*% t(pg_slope1_b4ofn10))) ## assume pgg_slope[11] = -2 
expon_pg2_b4ofn10 <- expit(as.vector(pg_int2) + t(modmat_pgg2 %*% t(pg_slope2_b4ofn10)))
expon_pg3_b4ofn10 <- expit(as.vector(pg_int3) + t(modmat_pgg3 %*% t(pg_slope3_b4ofn10)))

p_pg1_b4ofn10 <- expon_pg1_b4ofn10
p_pg2_b4ofn10 <- (1-expon_pg1_b4ofn10) * expon_pg2_b4ofn10
p_pg3_b4ofn10 <- (1-expon_pg1_b4ofn10) * (1-expon_pg2_b4ofn10) *expon_pg3_b4ofn10
p_pg4_b4ofn10 <- 1-(p_pg1_b4ofn10 + p_pg2_b4ofn10 + p_pg3_b4ofn10)

eta_fittedbgg_b4ofn10 <- get_eta_fittedbgg_table(p_pg1_b4ofn10, p_pg2_b4ofn10, p_pg3_b4ofn10, p_pg4_b4ofn10)
ave_eta_fittedbgg_b4ofn10 <- Reduce("+", eta_fittedbgg_b4ofn10)/length(eta_fittedbgg_b4ofn10)
round(ave_eta_fittedbgg_b4ofn10,2)



round(ave_eta_fittedbgg_b4of0,2)
round(ave_eta_fittedbgg_b4ofn1,2)
round(ave_eta_fittedbgg_b4ofn3,2)
round(ave_eta_fittedbgg_b4ofn10,2)

prop_ave_eta_fittedbgg_b4of0 <- prop.table(ave_eta_fittedbgg_b4of0, margin = 1)
prop_ave_eta_fittedbgg_b4ofn1 <- prop.table(ave_eta_fittedbgg_b4ofn1, margin = 1)
prop_ave_eta_fittedbgg_b4ofn3 <- prop.table(ave_eta_fittedbgg_b4ofn3, margin = 1)
prop_ave_eta_fittedbgg_b4ofn10 <- prop.table(ave_eta_fittedbgg_b4ofn10, margin = 1)
round(prop_ave_eta_fittedbgg_b4of0,2)
round(prop_ave_eta_fittedbgg_b4ofn1,2)
round(prop_ave_eta_fittedbgg_b4ofn3,2)
round(prop_ave_eta_fittedbgg_b4ofn10,2)

library(pheatmap)
# pdf('moderator-form2-b4plot.pdf')
# pheatmap(prop_ave_eta_fittedbgg_b4of0, cluster_rows = F, cluster_cols = F,
#          display_numbers = T, main = "moderator-form2-b4=0")
# pheatmap(prop_ave_eta_fittedbgg_b4ofn1, cluster_rows = F, cluster_cols = F,
#          display_numbers = T, main = "moderator-form2-b4=-1")
# pheatmap(prop_ave_eta_fittedbgg_b4ofn3, cluster_rows = F, cluster_cols = F,
#          display_numbers = T, main = "moderator-form2-b4=-3")
# pheatmap(prop_ave_eta_fittedbgg_b4ofn10, cluster_rows = F, cluster_cols = F,
#          display_numbers = T, main = "moderator-form2-b4=-20")
# dev.off()
library(RColorBrewer)
titles=paste0("Beta=", c(0,1,3,20))
proptables=list(prop_ave_eta_fittedbgg_b4of0,
            prop_ave_eta_fittedbgg_b4ofn1,
            prop_ave_eta_fittedbgg_b4ofn3,
            prop_ave_eta_fittedbgg_b4ofn10)
plot_list=list()
for (i in 1:length(proptables)){
  x=pheatmap(proptables[[i]], 
             cluster_rows = F, 
             cluster_cols = F,
             display_numbers = T,
             main = titles[i],
             color = rev(colorRampPalette(rev(brewer.pal(n = 7, name =
                                                       "RdYlBu")))(100)[1:50]),
             labels_row = c("pgg=1", "pgg=2", "pgg=3", "pgg=4"),
             labels_col = c("bgg=1", "bgg=2", "bgg=3", "bgg=4"))
  plot_list[[i]] = x[[4]]     ##to save each plot into a list. note the [[4]]
}
library(gridExtra)
library(ggplot2)
g<-do.call(grid.arrange,plot_list)
ggsave("moderator-form4-diffcol-positive.pdf",g, width = 20, height =16, units= "cm")

#beta4 = posterior fit
pg_slope1_b4ofpos <- pg_slope1; pg_slope1_b4ofpos[,11] <- -0.03229921
pg_slope2_b4ofpos <- pg_slope2; pg_slope2_b4ofpos[,11] <- -0.2659349
pg_slope3_b4ofpos <- pg_slope3; pg_slope3_b4ofpos[,11] <- 0.06623866

expon_pg1_b4ofpos <- expit(as.vector(pg_int1) + t(modmat_pgg1 %*% t(pg_slope1_b4ofpos))) ## assume pgg_slope[11] = -2 
expon_pg2_b4ofpos <- expit(as.vector(pg_int2) + t(modmat_pgg2 %*% t(pg_slope2_b4ofpos)))
expon_pg3_b4ofpos <- expit(as.vector(pg_int3) + t(modmat_pgg3 %*% t(pg_slope3_b4ofpos)))

p_pg1_b4ofpos <- expon_pg1_b4ofpos
p_pg2_b4ofpos <- (1-expon_pg1_b4ofpos) * expon_pg2_b4ofpos
p_pg3_b4ofpos <- (1-expon_pg1_b4ofpos) * (1-expon_pg2_b4ofpos) *expon_pg3_b4ofpos
p_pg4_b4ofpos <- 1-(p_pg1_b4ofpos + p_pg2_b4ofpos + p_pg3_b4ofpos)

eta_fittedbgg_b4ofpos <- get_eta_fittedbgg_table(p_pg1_b4ofpos, p_pg2_b4ofpos, p_pg3_b4ofpos, p_pg4_b4ofpos)
ave_eta_fittedbgg_b4ofpos <- Reduce("+", eta_fittedbgg_b4ofpos)/length(eta_fittedbgg_b4ofpos)
round(ave_eta_fittedbgg_b4ofpos,2)
prop_ave_eta_fittedbgg_b4ofpos <- prop.table(ave_eta_fittedbgg_b4ofpos, margin = 1)
y <- pheatmap(prop_ave_eta_fittedbgg_b4ofpos,
         cluster_rows = F, 
         cluster_cols = F,
         display_numbers = T,
         main = "Beta=post mean",
         color = rev(colorRampPalette(rev(brewer.pal(n = 7, name =
                                                       "RdYlBu")))(100)[1:50]),
         labels_row = c("pgg=1", "pgg=2", "pgg=3", "pgg=4"),
         labels_col = c("bgg=1", "bgg=2", "bgg=3", "bgg=4"))

#show absolute change in b4=posterior mean figure
# Think of colors? 
prop_ave_eta_fittedbgg_b4ofpos - prop_ave_eta_fittedbgg_b4of0 
pheatmap(ave_eta_fittedbgg_b4ofpos - ave_eta_fittedbgg_b4of0,
         cluster_rows = F, 
         cluster_cols = F,
         display_numbers = T,
         main = "difference in counts between beta = posterior mean and 0",
         
         labels_row = c("pgg=1", "pgg=2", "pgg=3", "pgg=4"),
         labels_col = c("bgg=1", "bgg=2", "bgg=3", "bgg=4"))
z <- pheatmap(prop_ave_eta_fittedbgg_b4ofpos -prop_ave_eta_fittedbgg_b4of0 ,
         cluster_rows = F, 
         cluster_cols = F,
         display_numbers = T,
         main = "difference between Beta = posterior mean and 0",
         color = (colorRampPalette(rev(brewer.pal(n = 7, name =
                                                       "RdYlBu")))(100)[1:100]),
         labels_row = c("pgg=1", "pgg=2", "pgg=3", "pgg=4"),
         labels_col = c("bgg=1", "bgg=2", "bgg=3", "bgg=4"))



plot_list2 <- list(plot_list[[1]], y[[4]])
g2<-do.call(grid.arrange,c(plot_list2, ncol = 2))
ggsave("moderator-form4-b4=0&postmean.pdf",g2, width = 20, height =8, units= "cm")
ggsave("moderator-form4-b4=0&postmean-diff.pdf",z, width = 16, height =12, units= "cm")


